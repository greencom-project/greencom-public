/** 
 * Coded By Giorgio Dal Toï¿½ on 15/mag/2013 
 *
 * Internet of Things Service Management Unit 
 * Pervasive Technologies Area
 * Istituto Superiore Mario Boella
 * Tel. (+39) 011 2276614
 * Email: daltoe@ismb.it
 * Email: giorgio.daltoe@gmail.com 
 * 
 * '||'  .|'''.|  '||    ||' '||''|.   
 *  ||   ||..  '   |||  |||   ||   ||  
 *  ||    ''|||.   |'|..'||   ||'''|.  
 *  ||  .     '||  | '|' ||   ||    || 
 * .||. |'....|'  .|. | .||. .||...|'
 *
 * Via Pier Carlo Boggio 61 
 * 10138 Torino, Italy
 * T 011/2276201; F 011/2276299
 * info@ismb.it
 */
package eu.greencom.localdatastorage.timeseries.impl;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.apache.log4j.Logger;

import com.fasterxml.jackson.databind.ObjectMapper;

import eu.greencom.api.domain.SampledValue;
import eu.greencom.api.domain.SampledValueImpl;
import eu.greencom.api.domain.TimeSeries;
import eu.greencom.api.domain.TimeSeriesImpl;
import eu.greencom.api.service.TimeSeriesManager;
import eu.greencom.localdatastorage.impl.MongoLocalDataStorage;
import eu.greencom.xgateway.localdatastorage.api.service.LocalDataStorage;

public class LocalTimeSeriesManager implements TimeSeriesManager {
	private static final Logger LOG = Logger
			.getLogger(LocalTimeSeriesManager.class);

	public static final String TIMESERIESCOLLECTIONNAME = "TimeSeries";
	public static final String SAMPLEDVALUECOLLECTIONNAME = "SampledValue";

	private LocalDataStorage store;

	public void activate() {
		LOG.info("Activating LocalTimeSeriesManager");
	}

	public void deactivate() {
		LOG.info("Deactivating LocalTimeSeriesManager");
	}

	public void bindLocalDataStorage(LocalDataStorage store) {
		LOG.info("Binding LocalDataStorage");
		this.store = store;
	}

	public void unbindLocalDataStorage(LocalDataStorage store) {
		LOG.info("Unbinding LocalDataStorage" + store);
		// ff
		this.store = null;
	}

	@Override
	public void create(String deviceID, String timeSeriesID, String unit) {
		LOG.debug("Attempt to create new timeseries");
		if (unit == null){
			LOG.warn("You are going to create a timeseries without unit");
		}

		Map<String, Object> timeSeries = new HashMap<String, Object>();
		timeSeries.put("_id", deviceID + "_" + timeSeriesID);
		timeSeries.put("deviceID", deviceID);
		timeSeries.put("timeSeriesID", timeSeriesID);
		timeSeries.put("unit", unit);
		// timeSeries.put("description", config.getDescription()); //I SUGGEST
		// TO ADD
		// timeSeries.put("timeScope", config.getTimeScope()); //I SUGGEST TO
		// ADD: instant/ranged values
		// timeSeries.put("collectionMethod", config.getCollectionMethod()); //I
		// SUGGEST TO ADD: polling/event based collectioning

		if (!store.put(TIMESERIESCOLLECTIONNAME, timeSeries)) {
			LOG.error("Creation of new timeseries failed");
		}
		LOG.debug("New timeseries (deviceID=" + deviceID + " timeSeriesID="
				+ timeSeriesID + ", unit=" + unit + ") created");

	}

	@Override
	public boolean exists(String deviceID, String timeSeriesID) {

		return store.exists(TIMESERIESCOLLECTIONNAME, deviceID + "_"
				+ timeSeriesID);
	}

	@Override
	public void removeTimeSeries(String deviceID, String timeSeriesID) {

		store.delete(TIMESERIESCOLLECTIONNAME, deviceID + "_" + timeSeriesID);
		store.delete(SAMPLEDVALUECOLLECTIONNAME, deviceID + "_" + timeSeriesID);
	}

	@Override
	public boolean put(String deviceID, String timeSeriesID, SampledValue value) {

		LOG.debug("Attempt to insert new sampledvalue for source " + deviceID
				+ "_" + timeSeriesID);
		try {
			ObjectMapper m = new ObjectMapper();
			String jsonValue = m.writeValueAsString(value);
			LOG.debug("received: " + jsonValue);
			return store.put(SAMPLEDVALUECOLLECTIONNAME, jsonValue);

		} catch (Exception e) {
			//ff
			LOG.error(LocalTimeSeriesManager.class.getSimpleName() + ": " + e, e);
		}
		return false;

	}

	@Override
	public boolean put(SampledValue value) {
		LOG.debug("Attempt to insert a SampledValue in the LocalDataStorage");
		if (value.get_id() == null || value.get_id().length() == 0) {
			LOG.debug("Id was autogenerated");
			value.set_id(UUID.randomUUID().toString());
		}
		try {
			ObjectMapper m = new ObjectMapper();
			String jsonValue = m.writeValueAsString(value);
			LOG.debug("received: " + jsonValue);
			return store.put(SAMPLEDVALUECOLLECTIONNAME, jsonValue);

		} catch (Exception e) {
			//ff
			LOG.error(LocalTimeSeriesManager.class.getSimpleName() + ": Exception received: " + e, e);
		}
		return false;

	}

	@Override
	public boolean[] put(List<SampledValue> values) {

		boolean[] ret = new boolean[values.size()];
		int i = 0;
		for (SampledValue v : values){
			ret[i++] = this.put(v);
		}

		return ret;
	}

	@Override
	public boolean put(String deviceID, String timeSeriesID,
			List<SampledValue> values) {
		for (SampledValue sv : values) {
			if (!put(deviceID, timeSeriesID, sv)){
				return false;
			}
		}
		return true;
	}

	@Override
	public void removeSampledValues(Map<String, Object> query) {

		// No need to list the items first
		((MongoLocalDataStorage) store).delete(SAMPLEDVALUECOLLECTIONNAME,
				query);
	}

	@Override
	public List<String> listTimeSeriesID() {
		List<Map<String, Object>> timeSeriesList = store.list(
				TIMESERIESCOLLECTIONNAME, null,LocalDataStorage.NO_LIMIT);
		List<String> ret = new LinkedList<String>();
		for (Map<String, Object> o : timeSeriesList) {
			ret.add((String) o.get("timeSeriesID"));
		}
		return ret;
	}

	@Override
	public SampledValue firstValue(String source) {
		LOG.warn("LocalTimeSeriesManager#first(String source) not yet implemented");
		return null;
	}

	@Override
	public SampledValue lastValue(String source) {
		LOG.warn("LocalTimeSeriesManager#last(String source) not yet implemented");
		return null;
	}

	@Override
	public TimeSeries getTimeSeries(String deviceID, String timeSeriesID,
			long start, long end) {

		Map<String, Object> timeSeries = store.get(TIMESERIESCOLLECTIONNAME,
				timeSeriesID);
		Map<String, Object> query = new HashMap<String, Object>();
		Map<String, Object> x = new HashMap<String, Object>();
		x.put("$gte", start);
		x.put("$lte", end);
		query.put("timestamp", x);
		query.put("_id", deviceID + "_" + timeSeriesID);
		List<Map<String, Object>> result = store.list(TIMESERIESCOLLECTIONNAME,
				query, LocalDataStorage.NO_LIMIT);

		List<SampledValue> sampledValueList = new LinkedList<SampledValue>();
		for (Map<String, Object> r : result) {
			sampledValueList.add(new SampledValueImpl((String) r
					.get("deviceID"), (String) r.get("timeSeriesID"), (Long) r
					.get("timestamp"), (Double) r.get("value")));
		}

		TimeSeries o = new TimeSeriesImpl(deviceID, timeSeriesID,
				(String) timeSeries.get("unit"), sampledValueList);
		return o;

	}

	@Override
	public List<SampledValue> getUnsentValues(int limit) {
		Map<String, Object> query=new HashMap<String,Object>();
		query.put("sent", false);
		LOG.info("Querying for unset values -> query: "+query);
		List<Map<String,Object>> res= store.list(SAMPLEDVALUECOLLECTIONNAME, query, limit);
		LOG.info("Query for unsent values has returned "+res.size()+" values");
		List<SampledValue> result=new LinkedList<SampledValue>();
		for(Map<String, Object> valuesMap:res){
			try{
				//ff I changed new Long((Long)valuesMap.get("timestamp")) to new one
				SampledValueImpl s=new SampledValueImpl((String)valuesMap.get("deviceID"), (String)valuesMap.get("timeSeriesID"), (Long)valuesMap.get("timestamp"), (Double)valuesMap.get("value"));
				s.set_id((String)valuesMap.get("_id"));
				LOG.trace("SampledValue from db entry: deviceID="+s.getDeviceID()+" timeSeriesID="+s.getTimeSeriesID()+" timestamp="+s.getTimestamp()+" value="+s.getValue());
				result.add(s);
			}catch(Exception e){
				LOG.error("Error while transforming db entry in SampledValue for device "+valuesMap.get("deviceID"),e);
			}
		}
		LOG.debug("Transformed "+result.size()+" SampledValue from "+res.size()+" db entries");

		return result;
	}

	public LocalDataStorage getStore() {
		return store;
	}

	public void setStore(LocalDataStorage store) {
		this.store = store;
	}
}
